# V0.1.0 追问解决方案

基于"v0.1.0进一步追问.md"的问题，逐条给出解决方案，等待确认后再修改代码。

---

## 问题1: 条件导入/try-except导入默认应该导入

### 当前行为
```
# === Optional packages (from conditional imports) ===
# ujson  # optional in utils.py:10
```
可选包默认被注释掉，需要 `--include-optional` 才能包含。

### 你的需求
1. 默认应该导入（不注释），方便小白一键使用
2. 区分 `conditional` 和 `try_except` 标签，而不是统一叫 `optional`
3. 保留代码位置提示

### 解决方案

**修改默认行为**：
- `--include-optional` 改为默认 `True`
- 新增 `--exclude-optional` 参数用于排除可选包

**细化标签**：
```
# === 条件导入 (Conditional Imports) ===
numpy  # conditional: if块内导入 in main.py:15

# === Try-Except 导入 ===
ujson  # try_except: 可选依赖 in utils.py:10
```

**新的输出格式**：
```
# Auto-generated by pyimport2pkg

# === Required packages ===
requests
pandas

# === Conditional imports (if块内) ===
pywin32  # conditional in platform.py:15

# === Try-except imports (可能有替代方案) ===
ujson  # try_except in utils.py:10
```

---

## 问题2: 动态导入如何区分可静态解析和不可静态解析

### 技术原理

**AST 解析层面**:
```python
# 可静态解析 - 参数是字符串字面量
importlib.import_module("numpy")
# AST: Call(args=[Constant(value="numpy")])
# ↑ ast.Constant 类型，可以直接取 value

# 不可静态解析 - 参数是变量
module_name = get_module()
importlib.import_module(module_name)
# AST: Call(args=[Name(id="module_name")])
# ↑ ast.Name 类型，是变量引用，无法知道运行时的值
```

**代码实现** (`parser.py:171-208`):
```python
def _handle_dynamic_import(self, node: ast.Call):
    first_arg = node.args[0]

    # 检查参数是否是字符串字面量
    if isinstance(first_arg, ast.Constant) and isinstance(first_arg.value, str):
        # 可静态解析：直接获取字符串值
        module_name = first_arg.value  # 如 "numpy"
    else:
        # 不可静态解析：用占位符标记
        module_name = "<dynamic>"
```

**为什么用 `<>` 标记**:
- `<` 开头的字符串不可能是合法的 Python 模块名
- 便于在后续 Filter 阶段统一过滤掉
- 类似的标记还有 `<syntax_error>`, `<read_error>`

### 无需修改
当前实现已经正确，只是需要在文档中解释清楚。

---

## 问题3: Python版本检测问题

### 当前实现的问题

```python
# filter.py
self.python_version = python_version or (
    sys.version_info.major,
    sys.version_info.minor,
)
```

当前使用的是**运行 pyimport2pkg 的 Python 版本**，而不是目标项目的 Python 版本。

### 解决方案

**方案A: 自动检测目标项目的Python版本**

检测优先级:
1. CLI 参数 `--python-version 3.8`
2. 目标项目的 `.python-version` 文件 (pyenv)
3. 目标项目的 `pyproject.toml` 中的 `requires-python`
4. 目标项目的 `setup.py` / `setup.cfg`
5. 目标项目虚拟环境的 Python 版本
6. 当前运行环境的 Python 版本 (最后兜底)

**实现代码**:
```python
def detect_python_version(project_root: Path) -> tuple[int, int] | None:
    """自动检测目标项目的Python版本"""

    # 1. 检查 .python-version (pyenv)
    pyenv_file = project_root / ".python-version"
    if pyenv_file.exists():
        version_str = pyenv_file.read_text().strip()
        # 解析 "3.8.10" -> (3, 8)
        ...

    # 2. 检查 pyproject.toml
    pyproject = project_root / "pyproject.toml"
    if pyproject.exists():
        # 解析 requires-python = ">=3.8"
        ...

    # 3. 检查虚拟环境
    for venv_dir in [".venv", "venv", "env"]:
        venv_path = project_root / venv_dir
        if venv_path.exists():
            # 读取 pyvenv.cfg 获取版本
            ...

    return None  # 未检测到
```

### 关于标准库数据来源

**当前实现**:
- Python 3.10+ 使用 `sys.stdlib_module_names`（内置）
- 其他版本使用硬编码的 `STDLIB_MODULES_FALLBACK` 列表

**数据来源**:
- `STDLIB_MODULES_FALLBACK` 是基于 Python 官方文档手动整理的
- 通过 `get_stdlib_modules(python_version)` 函数根据版本动态调整

**完整性问题**:
这个列表是基于 Python 3.11 整理的，然后通过版本判断来增减模块。理论上覆盖了主要模块，但可能有遗漏。

---

## 问题4: 错误标记应该向用户报告

### 当前行为
错误标记（`<syntax_error>`, `<read_error>`, `<dynamic>`）在 Filter 阶段被静默丢弃。

### 解决方案

**在 requirements.txt 中添加错误报告区域**:
```
# === Required packages ===
numpy
pandas

# === Errors (需要手动检查) ===
# [Syntax Error] main.py:25 - invalid syntax
# [Read Error] broken.py - UnicodeDecodeError
# [Dynamic Import] utils.py:30 - 无法静态分析: importlib.import_module(module_name)
```

**实现**:
1. Filter 返回三元组: `(third_party, filtered, errors)`
2. Exporter 新增 `errors` 区域
3. 错误信息包含: 错误类型、文件路径、行号、具体原因

---

## 问题5: Backports数据完整性

### 当前数据

```python
BACKPORTS = {
    "dataclasses": {"min_version": (3, 7), "package": "dataclasses"},
    "typing": {"min_version": (3, 5), "package": "typing"},
    "tomllib": {"min_version": (3, 11), "package": "tomli"},
    "zoneinfo": {"min_version": (3, 9), "package": "backports.zoneinfo"},
    "graphlib": {"min_version": (3, 9), "package": "graphlib-backport"},
    # ...
}
```

### 需要补充的 Backports

根据 PyPI 上的 backport 包搜索:

```python
BACKPORTS = {
    # 已有
    "dataclasses": {"min_version": (3, 7), "package": "dataclasses"},
    "typing": {"min_version": (3, 5), "package": "typing"},
    "tomllib": {"min_version": (3, 11), "package": "tomli"},
    "zoneinfo": {"min_version": (3, 9), "package": "backports.zoneinfo"},
    "graphlib": {"min_version": (3, 9), "package": "graphlib-backport"},

    # 需要补充
    "typing_extensions": {"min_version": (3, 8), "package": "typing-extensions"},
    "importlib.metadata": {"min_version": (3, 8), "package": "importlib-metadata"},
    "importlib.resources": {"min_version": (3, 7), "package": "importlib-resources"},
    "contextvars": {"min_version": (3, 7), "package": "contextvars"},
    "singledispatchmethod": {"min_version": (3, 8), "package": "singledispatchmethod"},
    "cached_property": {"min_version": (3, 8), "package": "backports.cached-property"},
    "strenum": {"min_version": (3, 11), "package": "strenum"},
    "exceptiongroup": {"min_version": (3, 11), "package": "exceptiongroup"},
    "taskgroup": {"min_version": (3, 11), "package": "taskgroup"},
}
```

### 标准库版本差异数据

当前的 `get_stdlib_modules()` 函数已经处理了版本差异:
```python
if python_version < (3, 11):
    stdlib.discard("tomllib")
if python_version < (3, 9):
    stdlib.discard("zoneinfo")
    stdlib.discard("graphlib")
# ...
```

**建议**: 补充更多版本差异数据，特别是 Python 3.12/3.13 移除的模块。

---

## 问题6: 补充经典不匹配映射

### 搜索后建议补充的映射

```python
CLASSIC_MISMATCHES_ADDITIONS = {
    # 日期时间处理
    "dateparser": ["dateparser"],
    "arrow": ["arrow"],
    "pendulum": ["pendulum"],
    "maya": ["maya"],

    # 调度/定时
    "schedule": ["schedule"],
    "apscheduler": ["APScheduler"],
    "rq": ["rq"],

    # 文件监控
    "watchdog": ["watchdog"],
    "inotify": ["inotify"],

    # Shell/进程
    "sh": ["sh"],
    "plumbum": ["plumbum"],
    "pexpect": ["pexpect"],

    # 密钥/凭证
    "keyring": ["keyring"],
    "keyrings": ["keyring"],

    # HTTP/网络
    "curl": ["pycurl"],
    "socks": ["PySocks"],
    "paramiko": ["paramiko"],
    "fabric": ["fabric"],

    # 数据验证
    "jsonschema": ["jsonschema"],
    "validators": ["validators"],

    # 配置文件
    "toml": ["toml"],
    "configobj": ["configobj"],
    "configparser": ["configparser"],  # backport

    # 日志
    "loguru": ["loguru"],
    "structlog": ["structlog"],

    # 图像/多媒体
    "imageio": ["imageio"],
    "wand": ["Wand"],
    "moviepy": ["moviepy"],
    "ffmpeg": ["ffmpeg-python"],

    # 科学计算
    "numba": ["numba"],
    "cupy": ["cupy"],
    "jax": ["jax"],
    "flax": ["flax"],

    # NLP
    "spacy": ["spacy"],
    "nltk": ["nltk"],
    "gensim": ["gensim"],
    "jieba": ["jieba"],

    # 网页抓取
    "scrapy": ["Scrapy"],
    "selenium": ["selenium"],
    "playwright": ["playwright"],
    "pyppeteer": ["pyppeteer"],

    # 数据库额外
    "clickhouse_driver": ["clickhouse-driver"],
    "elasticsearch": ["elasticsearch"],
    "neo4j": ["neo4j"],
    "cassandra": ["cassandra-driver"],

    # 消息队列
    "pika": ["pika"],
    "kafka": ["kafka-python"],
    "nats": ["nats-py"],

    # 云服务SDK
    "oss2": ["oss2"],  # 阿里云OSS
    "cos": ["cos-python-sdk-v5"],  # 腾讯云COS
    "qiniu": ["qiniu"],  # 七牛云

    # 其他常用
    "dotenv": ["python-dotenv"],
    "pathvalidate": ["pathvalidate"],
    "humanize": ["humanize"],
    "inflect": ["inflect"],
    "shortuuid": ["shortuuid"],
    "nanoid": ["nanoid"],
}
```

---

## 问题7: PTH注入模块

### 决定
保持现状，PyWin32 已经是最主要的 PTH 注入案例。如需要可以后续添加 pyobjc (macOS)。

---

## 问题8: 补充命名空间包映射

### 搜索后建议补充的命名空间包

```python
NAMESPACE_PACKAGES_ADDITIONS = {
    # Apache 项目
    "apache_beam": {
        "_default": "apache-beam",
    },

    # Airflow
    "airflow": {
        "_default": "apache-airflow",
        "providers": {
            "google": "apache-airflow-providers-google",
            "amazon": "apache-airflow-providers-amazon",
            "microsoft": {
                "azure": "apache-airflow-providers-microsoft-azure",
            },
            "postgres": "apache-airflow-providers-postgres",
            "mysql": "apache-airflow-providers-mysql",
            "http": "apache-airflow-providers-http",
        },
    },

    # Databricks
    "databricks": {
        "sdk": "databricks-sdk",
        "connect": "databricks-connect",
        "sql": "databricks-sql-connector",
    },

    # Snowflake
    "snowflake": {
        "connector": "snowflake-connector-python",
        "sqlalchemy": "snowflake-sqlalchemy",
        "snowpark": "snowflake-snowpark-python",
    },

    # Tensorflow 生态
    "tensorflow": {
        "_default": "tensorflow",
        "keras": "tensorflow",
        "data": "tensorflow",
    },
    "tf_keras": {
        "_default": "tf-keras",
    },
    "keras": {
        "_default": "keras",
    },

    # PyTorch 生态
    "torch": {
        "_default": "torch",
    },
    "torchvision": {
        "_default": "torchvision",
    },
    "torchaudio": {
        "_default": "torchaudio",
    },

    # Stripe
    "stripe": {
        "_default": "stripe",
    },

    # Twilio
    "twilio": {
        "_default": "twilio",
    },

    # Sentry
    "sentry_sdk": {
        "_default": "sentry-sdk",
    },

    # Alembic
    "alembic": {
        "_default": "alembic",
    },

    # Celery
    "celery": {
        "_default": "celery",
    },

    # Flask 扩展
    "flask_sqlalchemy": {"_default": "Flask-SQLAlchemy"},
    "flask_login": {"_default": "Flask-Login"},
    "flask_wtf": {"_default": "Flask-WTF"},
    "flask_cors": {"_default": "Flask-Cors"},
    "flask_restful": {"_default": "Flask-RESTful"},
    "flask_migrate": {"_default": "Flask-Migrate"},

    # Django 扩展
    "rest_framework": {"_default": "djangorestframework"},
    "django_filters": {"_default": "django-filter"},
    "corsheaders": {"_default": "django-cors-headers"},
    "debug_toolbar": {"_default": "django-debug-toolbar"},
}
```

---

## 问题9: 数据库错误日志

### 解决方案

**添加详细错误日志**:

```python
class DatabaseBuilder:
    def __init__(self, ...):
        self.failed_packages: list[dict] = []

    async def fetch_and_process_package(self, package_name, download_count) -> bool:
        try:
            info = await self.fetch_package_info(package_name)
            if not info:
                self.failed_packages.append({
                    "package": package_name,
                    "error": "package_not_found",
                    "detail": "PyPI returned 404"
                })
                return False
            # ...
        except httpx.TimeoutException:
            self.failed_packages.append({
                "package": package_name,
                "error": "timeout",
                "detail": "Request timed out after 30s"
            })
            return False
        except httpx.HTTPStatusError as e:
            self.failed_packages.append({
                "package": package_name,
                "error": "http_error",
                "detail": f"HTTP {e.response.status_code}"
            })
            return False
        except Exception as e:
            self.failed_packages.append({
                "package": package_name,
                "error": "unknown",
                "detail": str(e)
            })
            return False
```

**生成错误日志文件**:
```python
async def build(self, ...):
    # ... 构建完成后

    # 写入错误日志
    if self.failed_packages:
        log_path = self.db.db_path.parent / "build_errors.json"
        log_path.write_text(json.dumps(self.failed_packages, indent=2))
        print(f"Error log saved to: {log_path}")
```

**CLI 输出**:
```
Database built successfully!
  Total packages: 5000
  Successful: 4850
  Failed: 150

Error breakdown:
  - package_not_found: 80
  - timeout: 45
  - http_error: 20
  - unknown: 5

Detailed error log: ~/.pyimport2pkg/data/build_errors.json
```

---

## 问题10: 一对多输出添加下载量

### 当前输出
```
# cv2 -> Selected: opencv-python, Alternatives: opencv-contrib-python, opencv-python-headless
```

### 改进后输出
```
# cv2 -> Selected: opencv-python (10.5M downloads)
#        Alternatives: opencv-contrib-python (2.1M), opencv-python-headless (1.8M)
```

### 实现
```python
def export_requirements_txt(self, ...):
    # ...
    for result in multi_candidates:
        selected = result.resolved_package
        selected_downloads = next(
            (c.download_count for c in result.candidates if c.package_name == selected),
            0
        )
        alternatives = [
            f"{c.package_name} ({self._format_downloads(c.download_count)})"
            for c in result.candidates
            if c.package_name != selected
        ]
        lines.append(
            f"# {result.import_info.module_name} -> "
            f"Selected: {selected} ({self._format_downloads(selected_downloads)})"
        )
        lines.append(
            f"#        Alternatives: {', '.join(alternatives)}"
        )

def _format_downloads(self, count: int) -> str:
    """格式化下载量"""
    if count >= 1_000_000:
        return f"{count/1_000_000:.1f}M"
    elif count >= 1_000:
        return f"{count/1_000:.1f}K"
    return str(count)
```

---

## 修改计划汇总

| 序号 | 问题 | 修改内容 | 涉及文件 |
|------|------|----------|----------|
| 1 | 可选包默认导入 | 修改默认行为，细化标签 | `cli.py`, `exporter.py` |
| 2 | 动态导入 | 无需修改，只需文档说明 | - |
| 3 | Python版本检测 | 新增自动检测函数 | `filter.py`, `cli.py` |
| 4 | 错误报告 | 添加错误区域到输出 | `filter.py`, `exporter.py` |
| 5 | Backports完整性 | 补充数据 | `filter.py` |
| 6 | 经典映射 | 补充约50+映射 | `hardcoded.py` |
| 7 | PTH注入 | 保持现状 | - |
| 8 | 命名空间包 | 补充约30+映射 | `namespace.py` |
| 9 | 数据库错误日志 | 添加详细日志 | `database.py`, `cli.py` |
| 10 | 一对多下载量 | 添加下载量显示 | `exporter.py` |

---

## 等待确认

请确认以上方案是否符合预期，确认后我将开始修改代码。

如有任何问题需要调整，请告诉我。
